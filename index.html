<script>
/* ======= GAS via fetch (robusto, sem mexer no GAS) ======= */
const APP_URL = "https://script.google.com/macros/s/AKfycbxnTEhSw1u5Ib0jCqJsURoZM30VfCpfeqKqKvYpXdKgJDUPrw8Q8hScbSzw4zVkI7u0rw/exec";

async function call(fn, payload){
  const url = APP_URL + "?fn=" + encodeURIComponent(fn);
  const body = JSON.stringify(payload || {});
  // T1) POST simples (text/plain) — evita preflight na maioria dos casos
  try{
    const r = await fetch(url, {method:"POST", headers:{"Content-Type":"text/plain"}, body, cache:"no-store"});
    if(!r.ok) throw new Error("HTTP "+r.status);
    return await r.json();
  }catch(e1){
    // T2) POST sem cabeçalhos (alguns proxys/GAS aceitam melhor)
    try{
      const r2 = await fetch(url, {method:"POST", body, cache:"no-store"});
      if(!r2.ok) throw new Error("HTTP "+r2.status);
      return await r2.json();
    }catch(e2){
      // T3) GET de fallback (se o seu GAS espelhar doGet/doPost)
      try{
        const p = btoa(unescape(encodeURIComponent(body)));
        const r3 = await fetch(url + "&p=" + p, {method:"GET", cache:"no-store"});
        if(!r3.ok) throw new Error("HTTP "+r3.status);
        return await r3.json();
      }catch(e3){
        // Erro detalhado pra aparecer na UI
        throw new Error(
          "Falha ao chamar GAS ("
          + (e1.message||e1) + " / "
          + (e2.message||e2) + " / "
          + (e3.message||e3) + ")"
        );
      }
    }
  }
}
</script>
